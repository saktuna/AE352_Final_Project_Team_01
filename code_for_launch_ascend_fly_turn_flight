import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from math import sin, cos, sqrt, pi

class Params:
    mass = 1.378          # kg
    g = 9.81              # m/s^2
    l = 0.225             # m (Arm length)
    kt = 1.8e-5           # N / (rad/s)^2
    km = 2.5e-6           # Nm / (rad/s)^2 (Motor drag constant)
    
    # Inertias
    Ix = 0.02
    Iy = 0.02
    Iz = 0.04
    
    # Drag Constants
    rho = 1.225           # Air density
    Cd = 1.0              # Drag coeff (Assumed standard for flight)
    A = 0.05              # Frontal Area (approx)
    
    # Power Limits
    P_max = 1221.0        # Watts (V * I_max = 11.1 * 110)

params = Params()

class Gains:
    # Altitude (Z)
    kp_z = 2.0; kd_z = 1.5; ki_z = 0.05
    # Position (X, Y) -> Output is Roll/Pitch ref
    kp_xy = 0.4; kd_xy = 0.6
    # Attitude (Roll, Pitch) Inner Loop
    kp_att = 12.0; kd_att = 3.0
    # Yaw
    kp_psi = 2.0; kd_psi = 1.0

gains = Gains()

def simulation():
    # Time settings
    dt = 0.005  # 5ms timestep
    T_max = 150.0 # Total simulation time
    time_steps = int(T_max / dt)
    t_arr = np.linspace(0, T_max, time_steps)
    
    # State Vector: [x, y, z, vx, vy, vz, phi, theta, psi, p, q, r]
    state = np.zeros(12)
    
    # Integral error memory
    int_err_z = 0
    
    # Data logging
    log_pos = []
    log_vel = []
    log_att = [] # Defined: [phi, theta, psi]
    log_power = []
    log_time = []
    
    # Mission Phase Management (0=Takeoff, 6=Land)
    phase = 0
    
    # Phase start time placeholders
    t_phase_start = 0
    t_hover_start = 0
    t_move_y_start = 0
    t_hover2_start = 0
    t_land_start = 0
    
    print("Starting Simulation...")
    
    for i in range(time_steps):
        t = t_arr[i]
        x, y, z, vx, vy, vz, phi, theta, psi, p, q, r = state
        
        x_ref, y_ref, z_ref = 0, 0, 0
        psi_ref = 0
        
        if phase == 0: # Takeoff to 1m
            x_ref, y_ref, z_ref = 0, 0, 1.0
            if z > 0.95: 
                phase = 1
                t_phase_start = t
            
        elif phase == 1: # Move X (5m at 1m/s)
            time_in_phase = t - t_phase_start
            x_ref = min(5.0, time_in_phase * 1.0) # 1m/s slope
            y_ref, z_ref = 0, 1.0
            if x > 4.95: 
                phase = 2
                t_hover_start = t
            
        elif phase == 2: # Hover 1
            x_ref, y_ref, z_ref = 5.0, 0, 1.0
            if t - t_hover_start > 2.0: 
                phase = 3
            
        elif phase == 3: # Yaw 90 deg Left (pi/2)
            x_ref, y_ref, z_ref = 5.0, 0, 1.0
            psi_ref = np.pi/2
            if abs(psi - np.pi/2) < 0.05: 
                phase = 4
                t_move_y_start = t
            
        elif phase == 4: # Move Y (5m)
            time_in_phase = t - t_move_y_start
            x_ref = 5.0
            y_ref = min(5.0, time_in_phase * 1.0)
            z_ref = 1.0
            psi_ref = np.pi/2
            if y > 4.95: 
                phase = 5
                t_hover2_start = t
            
        elif phase == 5: # Hover 2
            x_ref, y_ref, z_ref = 5.0, 5.0, 1.0
            psi_ref = np.pi/2
            if t - t_hover2_start > 2.0: 
                phase = 6
                t_land_start = t
            
        elif phase == 6: # Land vertically at <= 1 cm/s
            x_ref, y_ref = 5.0, 5.0
            psi_ref = np.pi/2
            # Set descent rate to 0.008 m/s (slower than 0.01 m/s limit)
            z_ref = max(0.0, 1.0 - (t - t_land_start) * 0.008)
            
            # Kill motors if ground hit
            if z <= 0.01: 
                z_ref = 0
        
        # 1. Altitude Control (U1)
        err_z = z_ref - z
        derr_z = (0 - vz)
        int_err_z += err_z * dt
        U1 = params.mass * params.g + params.mass * (gains.kp_z * err_z + gains.kd_z * derr_z + gains.ki_z * int_err_z)
        
        # 2. Horizontal Position Control (Generates Phi_ref, Theta_ref)
        ex = x_ref - x
        ey = y_ref - y
        
        # Rotate errors to Body Frame
        ex_body = cos(psi)*ex + sin(psi)*ey
        ey_body = -sin(psi)*ex + cos(psi)*ey
        
        # PD for pos -> desired accel -> desired angle (small angle approx)
        theta_ref = (gains.kp_xy * ex_body + gains.kd_xy * (0 - (cos(psi)*vx + sin(psi)*vy))) 
        phi_ref = -(gains.kp_xy * ey_body + gains.kd_xy * (0 - (-sin(psi)*vx + cos(psi)*vy)))
        
        theta_ref = np.clip(theta_ref, -0.5, 0.5) # Clamp to approx 28 degrees
        phi_ref = np.clip(phi_ref, -0.5, 0.5)
        
        # 3. Attitude Control (U2, U3, U4)
        U2 = gains.kp_att * (phi_ref - phi) + gains.kd_att * (0 - p)     # Roll Torque
        U3 = gains.kp_att * (theta_ref - theta) + gains.kd_att * (0 - q) # Pitch Torque
        U4 = gains.kp_psi * (psi_ref - psi) + gains.kd_psi * (0 - r)     # Yaw Torque
        
        # Assuming near hover for power approximation
        w_sq_avg = U1 / (4 * params.kt)
        if w_sq_avg < 0: w_sq_avg = 0
        w_avg = sqrt(w_sq_avg)
        
        # P_total = 4 * w_avg * Q_avg = 4 * w_avg * (km * w_avg^2) = 4 * km * w_avg^3
        total_power = 4 * params.km * w_avg**3 
        
        # Drag D = 0.5 * rho * Cd * A * v^2
        v_sq = vx**2 + vy**2 + vz**2
        v_mag = sqrt(v_sq)
        Fx_drag, Fy_drag, Fz_drag = 0,0,0
        if v_mag > 0:
            drag = 0.5 * params.rho * params.Cd * params.A * v_sq
            Fx_drag = -drag * vx/v_mag
            Fy_drag = -drag * vy/v_mag
            Fz_drag = -drag * vz/v_mag
            
        # Acceleration (World Frame)
        # Thrust component: F_T = R * [0, 0, U1]
        ax = (cos(phi)*sin(theta)*cos(psi) + sin(phi)*sin(psi)) * U1 / params.mass + Fx_drag/params.mass
        ay = (cos(phi)*sin(theta)*sin(psi) - sin(phi)*cos(psi)) * U1 / params.mass + Fy_drag/params.mass
        az = -params.g + (cos(phi)*cos(theta)) * U1 / params.mass + Fz_drag/params.mass
        
        if z <= 0 and az < 0: # Ground collision check
            az = 0; vz = 0; z = 0
            
        # Angular Acceleration
        dp = (U2 - (params.Iz - params.Iy)*q*r)/params.Ix
        dq = (U3 - (params.Ix - params.Iz)*p*r)/params.Iy
        dr = (U4 - (params.Iy - params.Ix)*p*q)/params.Iz
        
        # Euler Integration
        vx += ax*dt; vy += ay*dt; vz += az*dt
        x += vx*dt; y += vy*dt; z += vz*dt
        p += dp*dt; q += dq*dt; r += dr*dt
        phi += p*dt; theta += q*dt; psi += r*dt
        
        # Store State
        state = [x, y, z, vx, vy, vz, phi, theta, psi, p, q, r]
        
        log_pos.append([x, y, z])
        log_vel.append([vx, vy, vz])
        log_att.append([phi, theta, psi]) # Logging att here
        log_power.append(total_power)
        log_time.append(t)
        
        if phase == 6 and z <= 0.001 and t > t_land_start + 1.0:
            print(f"Mission complete at t={t:.2f}s")
            break

    # Return the newly defined log_att
    return np.array(log_time), np.array(log_pos), np.array(log_vel), np.array(log_att), np.array(log_power)


t, pos, vel, att, pwr = simulation() 

# Create a 2x2 Plot Grid
fig = plt.figure(figsize=(12, 10))

# Plot 1: 3D Trajectory
ax1 = fig.add_subplot(221, projection='3d')
ax1.plot(pos[:,0], pos[:,1], pos[:,2], label='Drone Trajectory')
ax1.set_title('3D Flight Path')
ax1.set_xlabel('X (m)'); ax1.set_ylabel('Y (m)'); ax1.set_zlabel('Z (m)')

# Plot 2: Landing Velocity Check
ax2 = fig.add_subplot(222)
# Find index where landing phase begins to focus the plot
if t.size > 0:
    landing_start_time = t[-1] - 15.0 
    landing_start_idx = np.where(t >= landing_start_time)[0]
    if landing_start_idx.size > 0:
        landing_start_idx = landing_start_idx[0]
        ax2.plot(t[landing_start_idx:], vel[landing_start_idx:, 2])
    else:
        ax2.plot(t, vel[:, 2]) # Fallback if mission is too short
    
ax2.axhline(-0.01, color='r', linestyle='--', label='Limit (-1 cm/s)')
ax2.set_title('Landing Vertical Velocity')
ax2.set_xlabel('Time (s)'); ax2.set_ylabel('Vz (m/s)'); ax2.grid(True); ax2.legend()

# Plot 3: Euler Angles (phi, theta, psi)
ax3 = fig.add_subplot(223)
ax3.plot(t, np.degrees(att[:,0]), label='Roll ($\phi$)')
ax3.plot(t, np.degrees(att[:,1]), label='Pitch ($\\theta$)')
ax3.plot(t, np.degrees(att[:,2]), label='Yaw ($\psi$)')
ax3.set_title('Euler Angles vs Time')
ax3.set_xlabel('Time (s)'); ax3.set_ylabel('Angle (degrees)') # Plot in degrees for clarity
ax3.legend(); ax3.grid(True)
# 

# Plot 4: Power Consumption
ax4 = fig.add_subplot(224)
ax4.plot(t, pwr)
ax4.axhline(params.P_max, color='r', linestyle='--', label='Battery Max Limit (1221 W)')
ax4.set_title('Power Consumption')
ax4.set_xlabel('Time (s)'); ax4.set_ylabel('Watts'); ax4.grid(True)

plt.tight_layout()
plt.show()
